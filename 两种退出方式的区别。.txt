  PID  PGID  PPID   SID TT       COMMAND
30917 30917 30915 30917 pts/0    bash	自成一组。session创建者。（独立成为一个任务）
30936 30936 30917 30917 pts/0    ping	自成一组。bash的session。（独立成为一个任务）
31001 31001 30917 30917 pts/0    ps	自成一组。bash的session。（独立成为一个任务）

依靠父子进程的微妙关系去结束进程，恐怕会造成托管进程。而形成一个session就不一样了。不依赖父子关系，父子平级，但是都组织在了一个水平上。
给予它们(进程们)明确的组织方式，它这个gpid不会随着父进程退出、bash退出的影响而发生改变。
而父子关系中维护的PPID会随着各方面产生改变。
那么它们就始终组织一个进程组的结合。

常规退出时，进程组父进程常规结束时，子进程不会作结束。
非常规如：以Ctrl+z等信号退出方式，将会传播给整个进程组。这个是人为强制终止的行为。bash进程的退出也约等于是人为的。而非常规退出进程。


子进程是父进程的一个克隆

fork()便于为现有进程创建一个“一模一样”的拷贝，与不相干的两个进程相比，父子进程间的通信要方便的多。

父进程可以方便的等待子进程的结束，获取子进程的退出状态..


