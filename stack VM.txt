比如 这样
【管理员】SKY[夜空]落星星 2016/11/7 18:18:09
AS3内联AS3 的ASM 也就是opcode
【管理员】SKY[夜空]落星星 2016/11/7 18:18:20
和C是一个道理
【管理员】SKY[夜空]落星星 2016/11/7 18:18:32

【管理员】SKY[夜空]落星星 2016/11/7 18:18:46
那么实际内联的asm 和函数生成的ASM没本质的区别

【状元】SKY[渣渣]夏蛊 2016/11/7 18:18:51

那我理解的这种算什么
18:19:36
【状元】SKY[渣渣]夏蛊 2016/11/7 18:19:36
比如 
"user.getAddr()"
对应到脚本引擎中的user对象的getAddr方法，
站在语法层面上来说的话，各种操作符，关键字也用这种方式来实现，这种可能不
【管理员】SKY[夜空]落星星 2016/11/7 18:19:37
这种算是解析成语法树 然后执行这个语法树本身了，相当于parser
【管理员】SKY[夜空]落星星 2016/11/7 18:19:47
这种解释执行的 并没有JIT
【管理员】SKY[夜空]落星星 2016/11/7 18:19:54
所以也谈不上opcode

【状元】SKY[渣渣]夏蛊 2016/11/7 18:19:59
也就是存在这种东西了？

【状元】SKY[渣渣]夏蛊 2016/11/7 18:20:05
内定的语法执行器
【管理员】SKY[夜空]落星星 2016/11/7 18:20:10
可以

【状元】SKY[渣渣]夏蛊 2016/11/7 18:20:15
而不是语法转换器

【状元】SKY[渣渣]夏蛊 2016/11/7 18:20:27
哪些语言有这种设计结构的
【管理员】SKY[夜空]落星星 2016/11/7 18:21:24
一般 perl ruby等，是转分析树的
【管理员】SKY[夜空]落星星 2016/11/7 18:21:35
换句话说 转成分析树后 再也回不去了
18:21:39
【状元】SKY[渣渣]夏蛊 2016/11/7 18:21:39
这种算是解析成语法树 然后执行这个语法树本身了，相当于parser
对差不多这个意思，解析后，直接执行语法中包含的各种Handler标记了，而不是转换到Opcode
【管理员】SKY[夜空]落星星 2016/11/7 18:21:44
一般这种是解释执行的
【管理员】SKY[夜空]落星星 2016/11/7 18:21:51
也就是有interapter

【状元】SKY[渣渣]夏蛊 2016/11/7 18:21:55
perl ruby是不是我刚才说的那种

【状元】SKY[渣渣]夏蛊 2016/11/7 18:22:03
完全解释执行的状态
【管理员】SKY[夜空]落星星 2016/11/7 18:22:04
恩 ruby 1.8之前是的
【管理员】SKY[夜空]落星星 2016/11/7 18:22:14
ruby 1.9以后 改成YARV了
【管理员】SKY[夜空]落星星 2016/11/7 18:22:26
分析树型的 都是这样的

【状元】SKY[渣渣]夏蛊 2016/11/7 18:22:57
1.9开始就是转到二进制了吗
【管理员】SKY[夜空]落星星 2016/11/7 18:23:02
JAVA C#  AS3这类的相反 是分析树被取代了，是编译生成了字节码
18:24:34
【管理员】SKY[夜空]落星星 2016/11/7 18:24:34
YARV也是AST的
【管理员】SKY[夜空]落星星 2016/11/7 18:24:39
只不过改良了
【管理员】SKY[夜空]落星星 2016/11/7 18:24:45
带VM了
【管理员】SKY[夜空]落星星 2016/11/7 18:24:50
用的Stack VM
【管理员】SKY[夜空]落星星 2016/11/7 18:25:10
ruby目前还没有opcode的