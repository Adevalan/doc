        假设个例子，ITOO1.0开发完成，
这个时候要做一个tag，tag_release_1_0，然后基于这个tag做发布，tag就是一个版本的特殊标识.
tag_release_1_0 整个库的某一个版本号。该库中的每个文件都存储在存储库当中。相当于是svn内部存储库当中的硬链接。
版本和指向器是映射关系，如果没有指向器，那么该库的某个版本将不能访问。
当前版本的版本控制信息保存到xxx当中。一个副本出来了。

然后主干代码在不断的变化。有可能把这个版本给删除了，也有可能在原有的基础上进行修改。但tag中硬链接集的版本不会发生任何的改变，
以后有用到这个就创建一个branch进行修改，千万不要直接修改tag分支，它只是做一个快照而已。

如果发现了bug，那么针对这个tag创建一个分支，
之后修复bug，修复好bug后，再创建一个tag。保存当前这个修复后的版本。只作快照，不作合并，也不作修改。只可读，可进行复制的。

这是模拟现实生活中的开发，分步骤型的，方便进行管理。
一旦trunk发生改变，那么原大版本的文件集合将不好再恢复，
直接在大版本上打标记，而不基于文件来说的。
其实tag就是在某个版本上做个标记，方便还原用的。
直接在版本上打人可阅读的标记，即命名式的标记。

打个标记，而非复制，在某个版本库管理的文件范围内其一个标记。
其实所有的版本都在，而不是复制啊什么的，一直都存在的。只是为其中某些历史上存在的版本打上标记。
branch则是真正的拷贝新的版本，而不是去映射旧的文件，
主干上可能已经没有这个版本了。

比如安装程序等。

trunk进入 1.1的开发，

但是1.0发现了bug，
那么就需要基于tag_release_1_0做一个分支(branch)，branch_bugfix_1_0，基于这 个branch进行bug修改，等到bugfix结束，做一个tag，tag_release_1_0_1，然后，根据需要决定 branch_bugfix_1_0是否并入主干(trunk)。