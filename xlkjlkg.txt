18:44:42
【管理员】SKY[夜空]落星星 2016/11/7 18:44:42
再后来 也就是现在，
【状元】SKY[学生]神仙 2016/11/7 18:44:42


【状元】SKY[渣渣]夏蛊 2016/11/7 18:44:47
jvm在执行jvm!opcode的过程 是在parser还是在产生对应的cpu机器码
【进士】SKY[萌新]小和尚 2016/11/7 18:44:47
翻车。
【管理员】SKY[夜空]落星星 2016/11/7 18:44:51
oracle又重新玩起来了
18:45:01
【管理员】SKY[夜空]落星星 2016/11/7 18:45:01
oracle新出了芯片专门解析SQL的
【管理员】SKY[夜空]落星星 2016/11/7 18:45:24
应该是parser
【管理员】SKY[夜空]落星星 2016/11/7 18:45:37
只不过核心层面是个stack处理器
【管理员】SKY[夜空]落星星 2016/11/7 18:45:49
AVM2的核心是forth语言做的stack VM
【管理员】SKY[夜空]落星星 2016/11/7 18:45:55
foeth
【管理员】SKY[夜空]落星星 2016/11/7 18:46:03
forth类似汇编的高级版

【状元】SKY[渣渣]夏蛊 2016/11/7 18:46:39
我感觉jvm!opcode 直接转机器码有点牵强了。。需要设计的非常复杂。

我认为它应该是个parser 比如遇到00 70就执行 00 70对应的过程 

而不是00 70转到机器码去执行

【状元】SKY[渣渣]夏蛊 2016/11/7 18:46:56
这两个本质上 和设计难度上 差了不止一万倍。。。
18:47:51
【管理员】SKY[夜空]落星星 2016/11/7 18:47:51
是执行00 70的过程 并不转码
【管理员】SKY[夜空]落星星 2016/11/7 18:48:25
内存生成汇编并执行的过程

【状元】SKY[渣渣]夏蛊 2016/11/7 18:48:37
C/C++ 在这方面设计上好像就比它简单些
【管理员】SKY[夜空]落星星 2016/11/7 18:48:44
没有再静态写入的环节了
【管理员】SKY[夜空]落星星 2016/11/7 18:48:51
直接内存执行出去了

【状元】SKY[渣渣]夏蛊 2016/11/7 18:49:06
源码->assembly 伪代码->opcode
【管理员】SKY[夜空]落星星 2016/11/7 18:49:27
http://www.cppblog.com/vczh/category/9583.html
你可以看重造轮子狂人 vczh的JIT作品

【状元】SKY[渣渣]夏蛊 2016/11/7 18:49:33
看过了

【状元】SKY[渣渣]夏蛊 2016/11/7 18:49:38
他的脚本引擎

【状元】SKY[渣渣]夏蛊 2016/11/7 18:49:41
实现
【管理员】SKY[夜空]落星星 2016/11/7 18:49:41

【管理员】SKY[夜空]落星星 2016/11/7 18:49:49
一样 直接x86化了
18:50:02
【管理员】SKY[夜空]落星星 2016/11/7 18:50:02
花姐也有相应的解决方案

【状元】SKY[渣渣]夏蛊 2016/11/7 18:50:04
它这个是直接到x86？
18:50:14
【状元】SKY[渣渣]夏蛊 2016/11/7 18:50:14
有点混乱了。。。
【管理员】SKY[夜空]落星星 2016/11/7 18:50:21
http://seiran.mist.so/uncategorized/simple-ruby-mc-gen.html

【状元】SKY[渣渣]夏蛊 2016/11/7 18:50:56
jvm不是直接到x86，而是有x86实现的内定过程，jvm！opcode相当于是index，指向一个个过程。

【状元】SKY[渣渣]夏蛊 2016/11/7 18:51:08
而vczh的JIT作品是直接到x86？
【管理员】SKY[夜空]落星星 2016/11/7 18:51:20
vczh的是JIT => OPCODE =>静态x86
【管理员】SKY[夜空]落星星 2016/11/7 18:51:37


【状元】SKY[渣渣]夏蛊 2016/11/7 18:51:40
那为什么JVM不这样做
【管理员】SKY[夜空]落星星 2016/11/7 18:51:50
JVM也分厂商的

【状元】SKY[渣渣]夏蛊 2016/11/7 18:51:56
既然有生成x86代码的能力了
【管理员】SKY[夜空]落星星 2016/11/7 18:51:57
具体的  你得去看源码了
【状元】SKY[元素]Badder 2016/11/7 18:52:04
CMinus 
【状元】SKY[元素]Badder 2016/11/7 18:52:07
C-
【管理员】SKY[夜空]落星星 2016/11/7 18:52:09
oracle和gjc的压根不一样
18:52:40
【状元】SKY[渣渣]夏蛊 2016/11/7 18:52:40
那常用的脚本引擎是否也有这两种分支
【管理员】SKY[夜空]落星星 2016/11/7 18:52:50
vzch的更传统 类似  高级 =》 MASM => x86

【状元】SKY[渣渣]夏蛊 2016/11/7 18:52:52
就是底层 x86或底层 过程列表的区别
【管理员】SKY[夜空]落星星 2016/11/7 18:53:06
他的OPCODE非常接近MASM了
【进士】SKY[工作]Fury 2016/11/7 18:53:17
→_→
【进士】SKY[工作]Fury 2016/11/7 18:53:58
我只能知道一半星星叔说的专业术语←_←
【管理员】SKY[夜空]落星星 2016/11/7 18:53:58


【状元】SKY[渣渣]夏蛊 2016/11/7 18:54:03


【状元】SKY[渣渣]夏蛊 2016/11/7 18:54:10
这里是是啥意思

【状元】SKY[渣渣]夏蛊 2016/11/7 18:54:16

18:54:35
【状元】SKY[渣渣]夏蛊 2016/11/7 18:54:35
JVM最后还是生成了汇编，而不是去跑handlers？
【管理员】SKY[夜空]落星星 2016/11/7 18:54:53
vczh也搞过一个我说的那种的 直接一个死循环去解释堆栈 不生成x86
【管理员】SKY[夜空]落星星 2016/11/7 18:54:59
纯parser的

18:57:28
【状元】SKY[渣渣]夏蛊 2016/11/7 18:57:28
行吧，我只确认可以动态编译/转换出x86汇编的引擎存在就行了

【状元】SKY[渣渣]夏蛊 2016/11/7 18:57:35
之前一直认为这是不太可能的事情

【状元】SKY[渣渣]夏蛊 2016/11/7 18:57:37
XD

【状元】SKY[渣渣]夏蛊 2016/11/7 18:57:50
这种编译也应该是块状编译的

【状元】SKY[渣渣]夏蛊 2016/11/7 18:57:55
不太可能是一句一句的
【管理员】SKY[夜空]落星星 2016/11/7 18:58:06


【状元】SKY[渣渣]夏蛊 2016/11/7 18:58:08
按函数编译或者按文件编译
【管理员】SKY[夜空]落星星 2016/11/7 18:58:22
和我说的一样 STACK VM解释为主
【管理员】SKY[夜空]落星星 2016/11/7 18:59:58
实际上 JAVA比这个复杂
【管理员】SKY[夜空]落星星 2016/11/7 19:00:06
因为有hotspot

【状元】SKY[渣渣]夏蛊 2016/11/7 19:00:10
那么我如何确定一款脚本的底层是生成x86代码或者parser呢

【状元】SKY[渣渣]夏蛊 2016/11/7 19:00:21
最底层
19:00:36
【状元】SKY[渣渣]夏蛊 2016/11/7 19:00:36
如果追求效率的话，是否有什么规律可以辨别
【管理员】SKY[夜空]落星星 2016/11/7 19:00:39
看VM源码
【管理员】SKY[夜空]落星星 2016/11/7 19:00:45
只能这样
【管理员】SKY[夜空]落星星 2016/11/7 19:00:51
不同VM实现方式压根不一样

【状元】SKY[渣渣]夏蛊 2016/11/7 19:01:00
比如刚刚说的JVM，按你的意思是它正在跑各种handler

【状元】SKY[渣渣]夏蛊 2016/11/7 19:01:10
而vczh的是在生成各种handler，并跑起来
【管理员】SKY[夜空]落星星 2016/11/7 19:01:18
应该是
【管理员】SKY[夜空]落星星 2016/11/7 19:01:44
因为JAVA有JAVA的苦衷
【管理员】SKY[夜空]落星星 2016/11/7 19:01:54
JAVA本身有client和server编译两种
【管理员】SKY[夜空]落星星 2016/11/7 19:02:01
还得带hotspot

【状元】SKY[渣渣]夏蛊 2016/11/7 19:02:05
好吧。。那基本没法区分了，分析VM精力耗得太多了，前年分析过themida的vm handlers

【状元】SKY[渣渣]夏蛊 2016/11/7 19:02:08
不是人干的事情
【管理员】SKY[夜空]落星星 2016/11/7 19:02:24
直接出x86，没法优化了

【状元】SKY[渣渣]夏蛊 2016/11/7 19:02:34
是的
19:02:48
【状元】SKY[渣渣]夏蛊 2016/11/7 19:02:48
直接出x86跟编译型语言没什么区别
【管理员】SKY[夜空]落星星 2016/11/7 19:02:48
举个例子  9!=9*8*7*6*5*4*3*2*1

【状元】SKY[渣渣]夏蛊 2016/11/7 19:03:01
只是把编译过程移后了
【管理员】SKY[夜空]落星星 2016/11/7 19:03:04
9!=9*8*7*6*5*4*3*2*1=362880
【管理员】SKY[夜空]落星星 2016/11/7 19:03:28
那么 如果C++模板元去做，那么 编译后的代码就是 cout<<362880
【管理员】SKY[夜空]落星星 2016/11/7 19:03:41
也就是执行编译的是个立即数
【管理员】SKY[夜空]落星星 2016/11/7 19:03:52
如果纯C++编译，那么 肯定有计算过程

【状元】SKY[渣渣]夏蛊 2016/11/7 19:04:07
惰性》
【管理员】SKY[夜空]落星星 2016/11/7 19:04:05
C++执行的时候需要算 9*8*7*6*5*4*3*2*1